## java多线程锁的使用 
 ### 锁的场景
 - 多个玩家迁城到一个大地图点
   > 这个是AMS的大地图操作，对大地图点加锁，然后迁服。更新的时候，验证时间戳，如果正确，就更新
 - 获取池子的资源
   > 获取池子的一个资源，然后更新
 - 玩家的一个指令操作
   > 玩家多个更新操作，同时只能执行一个
 - 多个玩家修改联盟数据
   > 同步
 - 玩家加积分/联盟加积分
   > 同步锁
 - 扣玩家资源
   > 同步锁
 - hash并发操作
   - 数据一致性问题

## 总结
 - 游戏大多使用的是乐观锁，比如扣资源，玩家只有15个资源，玩家扣了14，但客户端显示错误，就服务器报错，重新显示
 - 是以玩家为中心的操作
 - 玩家加积分，可以是使用单线程，减少锁的操作。但需要防止死锁，也很少并发;也可以减少，玩家瞬时大量的任务触发
 - 线程按顺序执行，就可以减少很多问题
 - 锁不仅仅是互斥，还包括可见性
 - 加锁防止逸出，比如加积分，加积分是同步的，但还有set方法，没有加锁，就导致可能会有问题，需要封装
 - long 64位操作
### 数据一致性
 - 多读多写
 - 
 - 
 
### 所得类型
- 悲观锁
  > 每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。
- 乐观锁
  > 每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。
- 

### 乐观锁
### 悲观锁
 - synchronized 关键字
    - 特性
        - 可重入
        - jdk1.6以后，性能已经提升很多了，和reentrantLock 持平
    - 分析
        - synchronized 会在同步块分别形成monitorenter 和 monitorexit 两个字节码指令， 这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象
        - synchronized是重量级操作，状态转换消耗的时间有可能比用户时间还要长
        - 适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination)、锁粗化（Lock Coarsening）、轻量级（LightWeight Locking） 和偏向锁（Biased Locking）等
        - 内存模型
        - 
   - 顺序
      - 线程、主内存、工作内存三者交互关系
   ![img.png](img.png)
      - java内存模型定义了8中操作
       - read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
       - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
       - use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
       - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
       - store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
       - write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
       - lock：作用于主内存的变量，把一个变量标识为一条线程独占的状态
       - unlock : 作用域内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
       
   - 交互图
      ![img_1.png](img_1.png)
     
  - java 提供了monitorenter和monitorexit 来隐式地使用这两个操作
  - 可见性
  - 有序性
  - 可预见
  - monitorenter 指令
  - synchronized 进行线程阻塞和唤醒所带来了性能问题，阻塞同步
    - 加锁
    - 用户态核心转换
     - 维护锁计数器
    - 检查是否有被阻塞地线程需要唤醒
    - 线程上下文切换
      > 两次切换
      >  线程调度过程需要访问由操作系统和jvm共享地数据结构
      > 操作系统和jvm都要介入
      >  这个线程地缓存不一定在处理器地本地缓存
      >  频繁阻塞，无法使用完整地调度时间片
      > 
    - 内存栅栏，是缓存无效，刷新硬件地写缓冲，以及停止执行管道，无法排序优化

  - 锁优化
    - 适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination)、锁粗化（Lock Coarsening）、轻量级（LightWeight Locking） 和偏向锁（Biased Locking）等
    - 这些技术都是为了在线程之间有更高效的共享数据，以及解决竞争问题
    - 锁粗化 -- 实战191
    - 通常，对象分配操作的开销比同步的开销更低
   
  - syn 地使用
   - 对象内地多个方法加，synchronized，就会互相阻塞，可以使用同步块
   - syn锁定的是对象引用，
   - 静态方法加锁 是给class类上锁
     非静态方法加锁 是给对象上锁
  - 代码地优化
    - 缩小锁地范围
    - 减少锁地持有时间
    - 降低所得请求频率
    - 使用带有协调机制的独占锁，这些机制允许更高地并发性
    - 减小锁地粒度
    - 锁分段
    - 使用readWriteLock
    - 使用原子类