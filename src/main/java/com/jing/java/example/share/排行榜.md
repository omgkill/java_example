 # 服务器活动排行榜

  ![avatar](../image/rank1.png)
  ![avatar](../image/rank.jpg)
  
  ## 火鸡活动 , 单服排名 + 单服活动   
  1. 使用了框架
  2. 存储方式
     + 数据库存储，map缓存
  3. 排行榜
      + 通过map缓存获取。
      + 通过stream sort Comparator.comparingLong 排序。
      + 相同积分，根据积分时间比较
  4.  排期
     尽量使用吴洋的排期框架
   
 ## 单人活动   单服排名 + 全活动服
  1. 存储方式
      + 数据库存储，map和list 缓存.启动全部加载
  2. 积分
      + 阶段积分，map存储。实现Comparable接口。
      + 总积分，list存储。实现Comparable接口。
  3.  排行榜
      + 阶段积分，通过stream.sorted排序。
      +  总积分，每次加积分，Collections.sort排序。
  4.  历史排行榜
      + 每次活动结束，放入数据库
  5. 跨服加积分
      + 通过rmi调用
  6. 问题 
  > 玩家重复出现在排行榜
  ```
        private static SortedSet<UserScore> scoreRankSet = Collections.synchronizedSortedSet(new TreeSet<>());//阶段积分排名
        List<UserScore> list = new ArrayList<>();
        
  		UserScore userScore = new UserScore();
  		userScore.setUid("111111111");
  		userScore.setScore(1L);
  		
  		UserScore userScore1 = new UserScore();
  		userScore1.setUid("222222222");
  		userScore1.setScore(2L);
        // 放入list
  		list.add(userScore);
  		list.add(userScore1);
  
        // 放入map
  		Map<String, UserScore> map = new HashMap<>();
  		for (UserScore score:list) {
  			map.put(score.getUid(), score);
  		}
  		Collections.sort(list);
  		
  		for (int i = 0; i< list.size(); i++) {
  			scoreRankSet.add(list.get(i));
  		}
  		
  		UserScore myScore = map.get("111111111");
  		myScore.setScore(33L);
  		System.out.println(scoreRankSet.size());
  ```
  - TreeSet add方法,使用了treeMap的put方法
  ```
   public V put(K key, V value) {
          Entry<K,V> t = root;
          if (t == null) {
              compare(key, key); // type (and possibly null) check
  
              root = new Entry<>(key, value, null);
              size = 1;
              modCount++;
              return null;
          }
          int cmp;
          Entry<K,V> parent;
          // split comparator and comparable paths
          Comparator<? super K> cpr = comparator;
          if (cpr != null) {
              do {
                  parent = t;
                  cmp = cpr.compare(key, t.key);
                  if (cmp < 0)
                      t = t.left;
                  else if (cmp > 0)
                      t = t.right;
                  else
                      return t.setValue(value);
              } while (t != null);
          }
          else {
              if (key == null)
                  throw new NullPointerException();
              @SuppressWarnings("unchecked")
                  Comparable<? super K> k = (Comparable<? super K>) key;
              do {
                  parent = t;
                  cmp = k.compareTo(t.key);
                  if (cmp < 0)
                      t = t.left;
                  else if (cmp > 0)
                      t = t.right;
                  else
                      return t.setValue(value);
              } while (t != null);
          }
          Entry<K,V> e = new Entry<>(key, value, parent);
          if (cmp < 0)
              parent.left = e;
          else
              parent.right = e;
          fixAfterInsertion(e);
          size++;
          modCount++;
          return null;
      }
  ```
  
 ## 战场秘宝  单服排名 + 全服活动（包含竞技场）
 1. 使用框架
 2. 存储方式
    + 数据库存储，redis 缓存
 3. redis操作
    + 加积分，使用redis zIncrby(String key, String uid, long addScore)
     + 获取排行榜，redis zRevrangeByScoreWithScores(String key, long max, long min, int offset, int count)
 4.  加积分
     + 数据表跨服携带
     + 数据表与redis同时存储，并进行同步
 5、 redis key  最好是 key + scheduleId, 然后一周后清除数据

## 采集资源排行榜   排行榜
 1. 存储方式
     - 数据库，redis
 2. 积分
     - 每小时查询sql，存入redis
     - 玩家个人积分，当redis没有，从sql查询，再放入redis
 3. redis操作
     - 放入到有序列表，redis rPush(String key, String... value)
     - 获取排行榜，redis getRangeList(String key, int start, int end)
     - 存入玩家个人信息，hSet(String key, String field, String value)
     - 获取玩家个人信息，hGet(String key, String field)
 4.  排行榜
     - 单服排名，排除跨服玩家
     - 存入数据，是排行榜的两倍
     - 玩家信息查询数据库，联盟信息通过缓存获取
   
 ## 圣诞boss  全服排名 + 单服活动
 1. 使用框架
 2. 存储方式
    + 数据库表、map缓存、
    + 单服redis、全服redis
 3. 积分同步
     + 线程循环，把单服前100信息放入数据库，再从全服获取前100名信息
 4. 活动结束发奖
    积分再次同步，然后判断是否全服都已提交，没有，通过线程不断循环。直至全服都已提交数据。获取全服排名，发奖
 5、redis 操作
      + 加入玩家积分：redis zAdd(String key, String member, long score)
      + 获取排行榜：redis zRevrangeByScoreWithScores(String key, long max, long min, int offset, int count)
 6、排行榜
    +  玩家信息通过shareInfo
    + 联盟信息redis GLOBAL_ALLIANCE_INFO
 7、全服redis key与单服redis key 最好有区别
 
 
 ## 世界boss 全服排名 + 全活动服
 1. 数据存储
     + 数据库、map缓存
 2. 积分同步
     + 查询数据库，放入全服redis，再把全服数据下拉到本地redis
 3. redis操作
     + 删除 zRem(String key, String member)
     + 新加 zAdd(String key, String member, long score)
     + 获取排行榜 zRangByDesc(String key, long start, long end)
   
 ## 王国活动 分组排行榜
 1. 存储方式
     + 数据库表，map缓存，redis
 2. 积分同步
     + 查询数据库，放入全服redis，再把全服数据下拉到本地redis
 3. redis操作
     + redis key是 key + groupId
     + 删除 zRem(String key, String member)
     + 新加 zAdd(String key, String member, long score)
     + 获取排行榜 zRangByDesc(String key, long start, long end)
 4. 发奖
     + 起线程，等全部上报完后，再发奖
 5.  加积分同步
   
 ## 军事要塞
 1. 存储方式
     + 数据库表，map缓存、redis
 2. redis操作
     + 获取玩家 zScore(String key, String member)
     + 加积分redis zIncrby(String key, String member, long score)
     + 获取排行榜redis zRevrangeByScoreWithScores(String key, long max, long min, int offset, int count)
     + 母服获取排行榜  redis getOtherRedis(crossServerId)
 3. 排行榜
     + 玩家信息：shareInfo
     + 联盟信息，加联盟积分时，从缓存获取联盟信息，然后放入redis。
 4. 加积分同步   